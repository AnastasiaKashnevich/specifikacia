\documentclass[10pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}

%\usepackage{listings}
%\lstset{inputencoding=utf8,extendedchars=false,keepspaces=true,language=C++} 

\usepackage{caption}
\usepackage{verbatim}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{indentfirst}
\usepackage{syntax}
\usepackage{bytefield}
\usepackage{multicol}
\usepackage{longtable}



\usepackage{algpseudocode}
\usepackage{graphicx}

\usepackage[dvipsnames,usenames]{color}
\usepackage{hyperref}
\hypersetup{unicode,breaklinks=true}
%\usepackage{tikz}
%\usetikzlibrary{arrows,decorations.pathmorphing,backgrounds,positioning,fit,petri,calc,shapes.misc,shapes.geometric}
%\usepackage[chapter]{minted}
%\usepackage{ifplatform}

\textheight 24.0cm
\textwidth 16.2cm

\voffset -2cm
\hoffset .0cm
\oddsidemargin 0.5mm
\evensidemargin 0.5mm
\topmargin -0.4mm
\righthyphenmin=2
\hfuzz=12.7pt
\makeatletter
%\renewcommand\section{\@startsection {section}{1}{\z@}%
%                                   {3.5ex \@plus 1ex \@minus .2ex}%
%                                   {2.3ex \@plus.2ex}%
%                                   {\normalfont\Large\bfseries}}
%\renewcommand{\thesection}{\arabic{section}}
\@addtoreset{equation}{section}
\@addtoreset{figure}{section}
\@addtoreset{table}{section}

\newlength{\chaprule}
\newlength{\ATchapskip}
\setlength{\chaprule}{0.4\p@} \setlength{\ATchapskip}{10\p@} \advance \ATchapskip by -1\chaprule
\renewcommand{\@makechapterhead}[1]{%
    \ifdim\chaprule>6\p@ \setlength{\chaprule}{6\p@}\fi
    \vspace*{\ATchapskip}%
    %\noindent\rule{\textwidth}{\chaprule}\par%
    %\vskip 10\p@
    {\parindent \z@ \normalfont \ifnum \c@secnumdepth >\m@ne {\huge\bfseries \@chapapp\space \thechapter.}
        %\par\nobreak
        %\vskip 8\p@
        \fi \interlinepenalty\@M \huge\bfseries #1\par\nobreak \vskip 10\p@
        %\noindent\rule{\textwidth}{\chaprule}\par%
        \vskip\ATchapskip }}

%\@addtoreset{lstlisting}{section}
\makeatother

%\iflinux
%\else
%\ifwindows
%\makeatletter
%\newcommand{\minted@write@detok}[1]{%
%  \immediate\write\FV@OutFile{\detokenize{#1}}}%
%
%\newcommand{\minted@FVB@VerbatimOut}[1]{%
%  \@bsphack
%  \begingroup
%    \FV@UseKeyValues
%    \FV@DefineWhiteSpace
%    \def\FV@Space{\space}%
%    \FV@DefineTabOut
%    %\def\FV@ProcessLine{\immediate\write\FV@OutFile}% %Old, non-Unicode version
%    \let\FV@ProcessLine\minted@write@detok %Patch for Unicode
%    \immediate\openout\FV@OutFile #1\relax
%    \let\FV@FontScanPrep\relax
%%% DG/SR modification begin - May. 18, 1998 (to avoid problems with ligatures)
%    \let\@noligs\relax
%%% DG/SR modification end
%    \FV@Scan}
%    \let\FVB@VerbatimOut\minted@FVB@VerbatimOut
%
%\renewcommand\minted@savecode[1]{
%  \immediate\openout\minted@code\jobname.pyg
%  \immediate\write\minted@code{\expandafter\detokenize\expandafter{#1}}%
%  \immediate\closeout\minted@code}
%\makeatother
%\fi
%\fi


\newcommand{\dom}{\rm dom}
\newcounter{rem}[section]
\renewcommand{\therem}{\thesection.\arabic{rem}}
\newenvironment{Remark}{\par\refstepcounter{rem} \bf Замечание \therem. \sl}{\rm\par}
\renewcommand{\theequation}{\thesection.\arabic{equation}}
\renewcommand{\thefigure}{\thesection.\arabic{figure}}
\renewcommand{\thetable}{\thesection.\arabic{table}}
%\renewcommand{\thelstlisting}{\thesection.\arabic{lstlisting}}
%\renewcommand{\lstlistingname}{Листинг}

\renewcommand{\theenumi}{\arabic{enumi}}
\renewcommand{\labelenumi}{\theenumi)}
\newcommand{\udc}[1]{УДК #1}

\newcounter{lem}[section]
\renewcommand{\thelem}{\thesection.\arabic{lem}}
\newenvironment{Lemma}{\par\refstepcounter{lem}\bf Лемма \thelem. \sl}{\rm\par}

\newcounter{cor}[section]
\renewcommand{\thecor}{\thesection.\arabic{cor}}
\newenvironment{Corrolary}{\par\refstepcounter{cor}\bf Следствие \thecor. \sl}{\rm\par}
\newcounter{theor}[section]
\renewcommand{\thetheor}{\thesection.\arabic{theor}}
\newenvironment{Theorem}{\par\refstepcounter{theor}\bf Теорема \thetheor. \sl}{\rm\par}
%\let \kappa=\ae
\newcommand{\diag}{\mathop{\rm diag}}
\newcommand{\epi}{\mathop{\rm epi}}
\newenvironment{Proof}{\par\noindent\bf Доказательство.\rm}{ \par}

\newcounter{exam}[section]
\renewcommand{\theexam}{\thesection.\arabic{exam}}
\newenvironment{Example}{\par\refstepcounter{exam}\bf Пример \theexam. \sl}{\rm\par}

\newcounter{prob}[section]
\renewcommand{\theprob}{\thesection.\arabic{prob}}
\newenvironment{Problem}{\par\refstepcounter{prob}\bf Задача \theprob. \sl}{\rm\par}

\newcounter{sol}[section]
\renewcommand{\thesol}{\thesection.\arabic{sol}}
\newenvironment{Solution}{\par\refstepcounter{sol}\bf Решение. \rm}{\rm\par}

\newcounter{defin}[section]
\renewcommand{\thedefin}{\thesection.\arabic{defin}}
\newenvironment{Definition}{\par\refstepcounter{defin}\bf Определение \thedefin.\sl}{\rm\par}

\newcounter{answ}[section]
\renewcommand{\theansw}{\thesection.\arabic{answ}}
\newenvironment{Answer}{\par\refstepcounter{answ}\theansw. \rm}{\rm\par}

\newcounter{exerc}[section]
\renewcommand{\theexerc}{\thesection.\arabic{exerc}}
\newenvironment{Exercise}{\par\refstepcounter{exerc}\bf Упражнение \theexerc.\sl}{\rm\par}

\newcounter{algor}[section]
\renewcommand{\thealgor}{\thesection.\arabic{algor}}
\newenvironment{Algorithm}[3]{\par\refstepcounter{algor}{\bf Алгоритм \thealgor. }{\sl #1}\par{\bf Вход: }{\sl #2}\par{\bf Выход: }\sl #3\par{\bf Метод.}\par}{\rm\par}

\newcommand{\ljoq}{<<}
\newcommand{\rjoq}{>>}
\newcommand{\vraisup}{\mathop{\rm vraisup}}
\newcommand{\pr}{\mathop{\rm pr}}
\newcommand{\sgn}{\mathop{\rm sgn}}
\newcommand{\epsclos}{\mathop{\text{$\varepsilon$--замыкание}}}
\newcommand{\move}{\mathop{\text{переход}}}
\newcommand{\closure}{\mathop{\text{ЗАМЫКАНИЕ}}}
\newcommand{\goto}{\mathop{\text{ПЕРЕХОД}}}
\newcommand{\ACTION}{\text{ДЕЙСТВИЕ}}
\newcommand{\GOTO}{\text{ПЕРЕХОД}}
\newcommand{\shift}[1]{\textbf{п}#1}
\newcommand{\reduce}[1]{\textbf{св}#1}
\newcommand{\access}{\textbf{доп}}
%\captiondelim{. }

\captionsetup{labelsep=period}

%\setcounter{page}{3}
%\setcounter{section}{1}


\makeatletter
\def\@seccntformat#1{\csname the#1\endcsname.\quad}
\makeatother

\algrenewcommand\algorithmicwhile{\textbf{пока}}
\algrenewcommand\algorithmicdo{\textbf{ }}
\algrenewcommand\algorithmicend{\textbf{конец}}
\algrenewcommand\algorithmicif{\textbf{если}}
\algrenewcommand\algorithmicthen{\textbf{то}}
\algrenewtext{EndIf}{\textbf{всё}}
\algrenewcommand\algorithmicfor{\textbf{для}}
\algrenewtext{ForAll}{\textbf{для всех }}
\algrenewcommand\algorithmicelse{\textbf{иначе}}
\algrenewtext{ElsIf}{\textbf{инес }}
\algrenewtext{Procedure}{\textbf{алг }}
\algrenewtext{EndProcedure}{\textbf{кон }}

\newcommand{\nad}[2]{\genfrac{}{}{0pt}{0}{#1}{#2}}

\newcommand{\nullable}{\mathop{\textit{зануляется}}}
\newcommand{\firstpos}{\mathop{\textit{первые}}}
\newcommand{\lastpos}{\mathop{\textit{последние}}}
\newcommand{\followpos}{\mathop{\textit{следующие}}}

\newcommand{\myor}{\mathop{\textbf{или}}}

\newcommand{\myand}{\mathop{\textbf{и}}}

\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

\renewcommand{\syntleft}{\normalfont\itshape}
\renewcommand{\syntright}{}
%\renewcommand{\listingscaption}{Листинг}
%\renewcommand{\listoflistingscaption}{Список листингов}
\begin{document}
\begin{titlepage}
\begin{center}
\vspace*{8cm}

{\bf\Huge
Сообщение о языке программирования Lu

} \vspace{2.5cm}


\LARGE
\textbf{Кашневич А.А.}

 \vspace{2.5cm}

{17 марта 2019г.}

\end{center}
\end{titlepage}
\tableofcontents

\newpage

\chapter{Язык}
    \section{Лексемы и форма описания синтаксиса}

Синтаксис языка программирования Lu с помощью формул, состоящих из двух частей: первая часть содержит имя определяемого понятия, а затем, после метасимвола \textcolor{Green}{$|$}, идёт вторая часть, содержащая определение понятия. Также кроме метасимвола \textcolor{Green}{$|$} будут также использоваться следующие метасимволы:

\textcolor{Green}{$/$} --- означает\ \glqq или\grqq;

\textcolor{Green}{$\{\}$} --- содержимое этих скобок может повторяться любое число раз, в том числе и ни разу;

\textcolor{Green}{$( )$} --- содержимое данных скобок является необязательным;

\textcolor{Green}{$[ ]$} --- эти скобки группируют конструкции.

Текст программы на языке Lu состоит из лексем. В языке имеется три класса лексем:
\begin{enumerate}
    \item ключевые слова и идентификаторы;
    \item числа;
    \item литёры и строки.
    \item знаки операций и разделители.
\end{enumerate}
Лексемы --- это предопределённые константы, идентификаторы и знаки операций, формирующиеся из допустимых символов. В свою очередь, лексемы являются частью выражений, из которых в дальнейшем составляются операторы.
Никакая лексема не может разбиваться на части пробелами или комментариями. Опишем каждый класс лексем.
        \subsection{Ключевые слова и идентификаторы}
Идентификатор --- это слово, в состав которого могут входить символы латинского алфавита, цифры и знак подчёркивания. Идентификатор должен начинаться с буквы.
Прописные и строчные буквы считаются различными. Идентификатор не может совпадать ни с каким ключевым словом. Ключевые слова языка записываются как строчными, так и заглавными буквами. Ниже приведён список ключевых слов:        
\begin{multicols}{3}
\bf

better

big

const

clean

else

example

false

for

full8

full16

full32

full64

full128

good

Hello

If

log

log8

log16

log32

log64

main

negative

number

perem


small

summ

sign

string

time

then

true

Wrong

usl

Zero

\end{multicols}

Примеры идентификаторов: \texttt{Sun_52}, \texttt{car}, \texttt{f567}.   

    
        \subsection{Числа}
Числа --- это беззнаковые целые числа. Знаковые константы --- это беззнаковые константы, к которым применена унарная операция смены знака (операция\ \glqq$-$\grqq). Запись:

\textcolor{Green}{\syntax{\synt{число}$|$\synt{целое}\\
}}

\subsection{Литёры и строки}
Литёра --- это либо произвольный символ, заключённый в двойные (\verb1"1) кавычки. Строка --- это либо последовательность из ноль или более символов, заключённых в кавычки.
Открывающая кавычка должна совпадать с закрывающей. Если в строке требуется записать кавычку, совпадающую с открывающей, то кавычка должна быть продублирована.

Примеры строк:\\[0.1mm]

\noindent"{ }" --- пустая строка\\[0.1mm]

\noindent\texttt{"Good day!"}\\[0.1mm]

         \subsection{Знаки операций и разделители}
\begin{center}
\begin{multicols}{5}
\tt
\noindent[

\noindent]

\noindent(\\
)\\
<-\\
->\\
!\\
\^{ }\\
.\\
:\\
;\\
==\\
+\\
-\\
+{}+\\
-{}-\\
*\\
/\\
\%\\
\verb"\"\\
|\\
\&\\
!//\\
!\&\\
<\\
>\\
<{}<\\
>{}>\\
\{\\
\}\\
<=\\
>=\\
!=\\
||\\
//\\
\end{multicols}
\end{center}

Кроме лексем в любом месте программы могут встречаться комментарии. Комментарий --- это последовательность любых символов, заключённых между скобками \{ и \}. 


    \section{Структура программы}
Структура программы на языке Рысь выглядит так:

\syntax{\noindent\textbf{модуль} \textcolor{Green}{\synt{имя_модуля}}\\
\{\\
\textcolor{Green}{\{\synt{описание}\}}\\
\}%
}

Здесь

\noindent\textcolor{Green}{\syntax{\synt{имя_модуля}}} --- идентификатор, являющийся именем данного модуля;

\noindent\textcolor{Green}{\syntax{\synt{описание}}} --- описание типов, переменных, констант, алгоритмов и операций.


    \section{Описания}

Область видимости объекта \texttt{x} (здесь под объектом понимается тип, переменная, константа, алгоритм или операция) текстуально распространяется от точки его описания до
конца блока (модуля, тела составного оператора, тела подпрограммы), к которому принадлежит описание и по отношению к которому объект, таким образом, считается локальным. Из
этой области исключаются области видимости объектов с аналогичным именем (вне зависимости с заглавной или строчной буквы начинается имя), описанных в блоках, вложенных в данный. Правила видимости таковы:
\begin{enumerate}
    \item Идентификатор может обозначать только один объект в данной области видимости (т.е. никакой идентификатор не может быть объявлен в блоке дважды).
    \item Аналогичный индитификатор, начинающийся с заглавной (или прописной) буквы также не может быть объявлен в блоке дважды.
    \item На объект можно сослаться только в его области видимости.
    \item Описание типа \texttt{T}, содержащее ссылки на другой тип \texttt{T}$_1$, может стоять в точках, где \texttt{T}$_1$ еще не известен. Описание типа \texttt{T}$_1$
должно следовать далее в том же блоке, в котором локализован \texttt{T}.
    \item Заголовок функции может быть приведён до того, как будет дано полное определение.
\end{enumerate}

        \subsection{Описание типов}
Описание типов выглядит так:
\begin{center}
\noindent\textbf{тип} \textcolor{Green}{\syntax{\synt{имя_типа}\textcolor{Black}{\texttt{-}}%
\synt{определение_типа}\noindent[\textcolor{Black}{\synt{имя_типа}\textcolor{Black}{\texttt{-}}}%
\synt{определение_типа}\noindent]}}
\end{center}

Здесь \textcolor{Green}{\syntax{\synt{имя_типа}}} --- идентификатор, являющийся именем определяемого типа; \textcolor{Green}{\syntax{\synt{определение_типа}}} --- либо
простейшее определение типа, либо определение алгебраического типа данных.

Алгебраические типы данных будут подробно рассмотрены позже. 

Простейшие определения типов есть двух категорий:
\begin{enumerate}
    \item стандартные типы;
    \item простейшие определения типов, задаваемые пользователем.
\end{enumerate}

Стандартные типы можно разделить на четыре вида:
\begin{enumerate}
    \item логические типы;
    \item символьные типы;
    \item числовые типы;
    \item перечисляемый тип;
\end{enumerate}

К простейшим определениям типов, задаваемым пользователем, относятся:
\begin{enumerate}
    \item имя типа;
    \item определение типа--указателя;
    \item определение типа указателя на функцию;
    \item определение типа--массива.
\end{enumerate}

Чтобы узнать размер переменной любого из типов необходимо перед именем типа или переменной этого типа поставить знак операции \texttt{*}.

Для динамических массивов операция \texttt{*} даёт размер не самого этого значения, а размер служебной информации. Чтобы узнать размер сам\'{о}го
значения динамического массива, нужно перед именем переменной поставить знак операции \texttt{.*}.

        \subsubsection{Логические типы}

Переменная логического типа может принимать только два значения: \textbf{true} или \textbf{false}. Логический тип выглядит так:
\begin{center}
\noindent\textcolor{Green}{\syntax{[\{\textcolor{Black}{\textbf{big}}\}/\{\textcolor{Black}{\textbf{small}}\}]}\textcolor{Black}{\textbf{log}} }\end{center}

Имеются логические типы конкретных размеров, а именно, типы \textbf{log8}, \textbf{log16},
\textbf{log32}, \textbf{log64}, переменные которых имеют размер в 1, 2, 4 и 8 байт соответственно.

Над логическими значениями определены следующие операции:
\begin{longtable}{ll}
\texttt{//}             & логическое\ \glqq или\grqq\       \\
\texttt{\&\&}           & логическое\ \glqq и\grqq\   \\
\texttt{!//}            & логическое\ \glqq не--или\grqq\ \\
\texttt{!\&\&}          & логическое\ \glqq не--и\grqq\ \\

\texttt{!}              & логическое\ \glqq не\grqq\                                \\
\texttt{==}             & равно                                                     \\
\texttt{!=}             & не равно                                                  \\
\end{longtable}
        

Все логические типы попарно совместимы между собой. 

Приведём таблицы истинности логических операций.

\begin{center}
\vspace{5mm}
\begin{longtable}{|l|l|l|l|}  \hline
\texttt{x}          & \texttt{y}        & \texttt{x//y}     & \texttt{x\&\&y}    \\  \hline
\textbf{false}       & \textbf{false}     & \textbf{false}     & \textbf{false}             \\  \hline
\textbf{false}       & \textbf{true}   & \textbf{true}   & \textbf{false}         \\  \hline
\textbf{true}     & \textbf{false}     & \textbf{true}   & \textbf{false}            \\  \hline
\textbf{true}     & \textbf{true}   & \textbf{true}   & \textbf{true}   \\ 
\hline
\end{longtable}

\begin{longtable}{|l|l|l|l|}  \hline
\texttt{x}          & \texttt{y}        & \texttt{(x!//y)}  &\texttt{(x!\&\&y)}  \\  \hline
\textbf{false}       & \textbf{false}     & \textbf{true}                   & \textbf{false}                         \\  \hline
\textbf{false}       & \textbf{true}   & \textbf{false}                     & \textbf{false}                         \\  \hline
\textbf{true}     & \textbf{false}     & \textbf{true}                   & \textbf{true}                       \\  \hline
\textbf{true}     & \textbf{true}   & \textbf{false}                     & \textbf{false}                         \\  \hline
\end{longtable}


\begin{longtable}{|l|l|}  \hline
 \texttt{x}         & \texttt{!x}       \\  \hline
\textbf{false}       & \textbf{true}   \\  \hline
\textbf{true}     & \textbf{false}     \\  \hline
\end{longtable}
\end{center}

        \subsubsection{Символьные типы}
Переменная символьного типа может хранить любой символ, доступный в конкретной реализации. Символьный тип выглядит так:
\begin{center}
\noindent\textbf{sign}
\end{center}

Для символьных данных определены лишь операции отношения и операция присваивания. Ниже приведён список операций отношения:

\begin{tabular}{ll}
 \texttt{<}         & меньше                                        \\
 \texttt{>}         & больше                                        \\
 \texttt{<=}        & меньше или равно                              \\
 \texttt{>=}        & больше или равно                              \\
 \texttt{==}        & равно                                         \\
 \texttt{!=}        & не равно                                      \\
\end{tabular}

        \subsubsection{Строковые типы}
Переменная строкового типа хранит строковые значения. Символьный тип выглядит так:
\begin{center}
\noindent\textbf{string}
\end{center}

Для строковых данных определены операции отношения, операция присваивания, и операция обращения к символу строки по его индексу. Также определена операция объединения строк, обозначаемая знаком \glqq\texttt{+}\grqq.

        \subsubsection{Числовые типы}
            \paragraph{Целочисленные типы.}Переменные целочисленных типов предназначены для хранения целых чисел. Целочисленный тип выглядит так:
\begin{center}
\noindent\textcolor{Green}{\syntax{[\{\textcolor{Black}{\textbf{big}}\}/\{\textcolor{Black}{\textbf{small}}\}]}\textcolor{Black}{\textbf{full}} }\end{center}
Имеются логические типы конкретных размеров, а именно, типы \textbf{full8}, \textbf{full16},
\textbf{full32}, \textbf{full64}, \textbf{full128}.

Допустимые операции:
\begin{longtable}{ll}
\texttt{+}    & целочисленное сложение                         
\\
\texttt{-}    & целочисленное вычитание                         
\\
\texttt{+{}+}           & следующее значение                                \\
\texttt{-{}-}           & предыдущее значение                               \\
\texttt{*}              & целочисленное умножение                           \\
\texttt{:}              & целочисленное деление                             \\
\texttt{\%}             & целочисленный остаток от деления                  \\
\texttt{**}             & целочисленное возведение в степень                \\
\texttt{/}              & поразрядное\ \glqq или\grqq\                      \\
\texttt{!/}         & поразрядное\ \glqq не--или\grqq\          
\\
\texttt{\&}             & поразрядное\ \glqq и\grqq\                        \\
\texttt{!\&}        & поразрядное\ \glqq не--и\grqq\                    \\
\texttt{!!}          & поразрядное\ \glqq не\grqq\                       \\
\texttt{<{}<}           & сдвиг влево                                       \\
\texttt{>{}>}           & сдвиг вправо                                      \\
\texttt{<}              & меньше                                            \\
\texttt{>}              & больше                                            \\
\texttt{<=}             & меньше или равно                                  \\
\texttt{>=}             & больше или равно                                  \\
\texttt{==}             & равно                                             \\
\texttt{!=}             & не равно                                          \\
\end{longtable}
        
        \subsubsection{Перечисляемый тип}
Отражает самый прямолинейный способ описания простого типа — перечисление всех значений, относящихся к этому типу. Каждая константа такого типа получает свой порядковый номер. Перечисляемый тип выглядит так: 
\begin{center}
\noindent\textbf{number}
\end{center}

        \subsubsection{Кортежи}
Кортеж --- это упорядоченный набор конечного числа элементов, вообще говоря, разных типов. Тип--кортеж выглядит так:
\begin{center}
\noindent\textcolor{Green}{\textcolor{Black}{[:}(\syntax{тип_элемента}\{\textcolor{Black}{,}\syntax{тип_элемента}\})\textcolor{Black}{:]}}
\end{center} 
   
Здесь \textcolor{Green}{\syntax{\synt{тип_элемента}}}  --- тип соответствующего элемента кортежа. Этот тип может быть либо именем типа, либо указателем, либо типом указателя на функцию, либо встроенным типом, либо кортежем.

Если для каждого элемента кортежа определена одна и та же операция отношения, то эта операция определена и для всего кортежа.

Кроме того, если $x$ --- значение--кортежа, то можно получить значения отдельных элементов этого кортежа. А именно, для получения значения элемента с номером $i$ (элементы кортежа нумеруются слева направо, и нумерация начинается с нуля), нужно написать $x\texttt{*}i$.

        \subsubsection{Указатели}
Указатели содержат адреса ячеек памяти. Тип--указатель определяется так:
\begin{center}
\noindent\textcolor{Green}{\syntax{\textcolor{Black}{@}\synt{простейшее_определение_типа} }}
\end{center}

Указателю можно присвоить константу \textbf{ничто}. В этом случае указатель перестаёт указывать на какую бы то ни было ячейку памяти. Указатель можно разыменовывать, то есть
получать значение переменной, на которую он указывает. Для разыменования указателя нужно после имени указателя поставить знак \texttt{@}. Разыменовывать можно все указатели,
кроме указателей типа \texttt{@}\textbf{ничто}. Тип переменной, на которую указывает указатель, называется базовым типом указателя.

Указатели можно сравнивать на равенство и неравенство. 

Указателю типа \texttt{@}\textbf{ничто} можно присваивать значение указателя любого типа.

        \subsubsection{Ссылки}
Тип--ссылка выглядит так:        
\begin{center}
\noindent\textcolor{Green}{\syntax{[\textcolor{Black}{\textbf{ссылка}}/\textcolor{Black}{\textbf{конст ссылка}}]\synt{простейшее_определение_типа}}}
\end{center}
        
        \subsubsection{Типы указателей на функции}

Переменные таких типов предназначены для хранения указателей на функции. Тип указателя на функцию выглядит так:
\begin{center}
\noindent\textcolor{Green}{\textcolor{Black}{\textbf{функция}} \synt{сигнатура} }
\end{center}

Здесь \textcolor{Green}{\syntax{\synt{сигнатура}}} определяется следующими формулами:

\textcolor{Green}{\syntax{%
%
\synt{сигнатура}$|$\textcolor{Black}{[}(\synt{группа_параметров}\{\textcolor{Black}{;}\synt{группа_параметров}\})\textcolor{Black}{]:}\synt{тип_значения}\\
%
\indent\synt{группа_параметров}$|$\synt{имя_параметра}\{\textcolor{Black}{,}\synt{имя_параметра}\}\textcolor{Black}{:}\synt{тип_параметра}\\
%
\indent\synt{имя_параметра}$|$\synt{идентификатор}\\
}}

        \subsubsection{Массивы}
Тип--массив имеет следующий вид:
\begin{center}
\noindent\textcolor{Green}{\syntax{\textcolor{Black}{\textbf{массив}}\textcolor{Black}{[} [\synt{выражение}]\{\textcolor{Black}{,}[\synt{выражение}]\} \textcolor{Black}{]}%
\synt{простейшее_определение_типа} }}
\end{center}


Если какое--либо из выражений опущено, то по этому измерению массив считается динамическим. Каждое из выражений указывает, сколько значений может принимать соответствующий
индекс массива. Каждое выражение должно быть таким, чтобы его можно было вычислить на этапе компиляции. Наименьшее значение каждого индекса равно нулю, а массивы хранятся по
строкам.

При этом записи
\begin{center}
\textbf{массив}[\texttt{N}$_0$,\dots,\texttt{N}$_{m-1}$] \textbf{массив}[\texttt{N}$_{m}$,\dots,\texttt{N}$_{m+p-1}$] \texttt{T}
\end{center}
и
\begin{center}
\textbf{массив}[\texttt{N}$_0$,\dots,\texttt{N}$_{m-1}$,\texttt{N}$_{m}$,\dots,\texttt{N}$_{m+p-1}$] \texttt{T}
\end{center}
считаются эквивалентными.

Далее, если тип \texttt{T} определён как
\begin{center}
\textbf{массив}[\texttt{N}$_{m}$,\dots,\texttt{N}$_{m+p-1}$] \texttt{T}$'$
\end{center}
то запись
\begin{center}
\textbf{массив}[\texttt{N}$_0$,\dots,\texttt{N}$_{m-1}$] \texttt{T}
\end{center}
считается эквивалентной записи
\begin{center}
\textbf{массив}[\texttt{N}$_0$,\dots,\texttt{N}$_{m-1}$,\texttt{N}$_{m}$,\dots,\texttt{N}$_{m+p-1}$] \texttt{T}$'$
\end{center}

Кроме того, любой тип вида
\begin{center}
\textbf{массив}[\texttt{N}$_0$,\dots,\texttt{N}$_{m-1}$] \texttt{T}
\end{center}
где тип \texttt{T} эквивалентен типу \textbf{ничто}, сам эквивалентен типу \textbf{ничто}.

Все эти преобразования производятся на этапе компиляции.

Для обращения к элементу массива надо после имени массива в квадратных скобках перечислить индексы нужного элемента.

Тип элемента массива называется базовым типом массива.

Для массивов определена инфиксная бинарная операция \texttt{\#}, первым (левым) операндом которой служит имя массива, а вторым (правым) --- номер индекса массива, считая слева.
Самый левый индекс имеет номер ноль. В результате вычисления данной операции будет получено количество возможных значений указанного вторым операндом индекса. Так происходит,
если второй аргумент неотрицателен и меньше количества индексов (с учётом преобразований этапа компиляции). Если же второй аргумент операции \texttt{\#} либо отрицателен, либо
не меньше количества индексов массива, то результат будет равен нулю.

        \subsubsection{Алгебраические типы данных}
Определение алгебраического типа данных имеет следующий вид:

\textcolor{Green}{\syntax{%
%
\synt{опр_алгебр_типа}$\to$\synt{компонента}\{\textcolor{Black}{\texttt{.|.}}\synt{компонента}\}\\
%
\indent\synt{компонента}$\to$\synt{опр_структуры}|\synt{опр_перечисления}\\
%
\indent\synt{опр_структуры}$\to$\textcolor{Black}{\textbf{структура}} \synt{имя_структуры} \textcolor{Black}{\{}\synt{тело_структуры}\textcolor{Black}{\}}\\
%
\indent\synt{опр_перечисления}$\to$\textcolor{Black}{\textbf{перечисление}} \synt{имя_перечисления} \textcolor{Black}{\{}\synt{тело_перечисления}\textcolor{Black}{\}}\\
%
\indent\synt{тело_структуры}$\to$[\synt{группа_полей}\{\textcolor{Black}{;}\synt{группа_полей}\}]\\
%
\indent\synt{группа_полей}$\to$\synt{имя_поля}\{,\synt{имя_поля}\}\textcolor{Black}{:}\synt{тип_поля}\\
%
\indent\synt{тело_перечисления}$\to$\synt{имя_значения}\{,\synt{имя_значения}\}
}}

    \subsection{Описание переменных}  
Синтаксис описания переменных:

\textcolor{Green}{%
\syntax{%
\synt{описание_переменных}$|$\textcolor{Black}{\textbf{perem}} \synt{группа_переменных} \textcolor{Black}{:} \synt{простейшее_определение_типа}\\
\{\textcolor{Black}{;}\synt{группа_переменных} \textcolor{Black}{:} \synt{простейшее_определение_типа}\}\\
%
\indent\synt{группа_переменных}$|$\synt{переменная}\{\textcolor{Black}{,} \synt{переменная}\}\\
%
\indent\synt{переменная}$|$\synt{имя_переменной}\\
%
\indent\synt{имя_переменной}$|$\synt{идентификатор}
}}

Необязательная звёздочка после имени переменной означает, что переменная доступна из других модулей. Отсутствие звёздочки означает недоступность переменной из других модулей.

    \subsection{Описание констант}
Синтаксис описания констант:

\textcolor{Green}{%
\syntax{%
\synt{описание_констант}$|$\\
\textcolor{Black}{\textbf{const}} \synt{имя_константы} \textcolor{Black}{:} \synt{простейшее_определение_типа} \textcolor{Black}{\texttt{=}} %
\synt{значение_константы}\\
\{\textcolor{Black}{;}\synt{имя_константы}\textcolor{Black}{:} \synt{простейшее_определение_типа} \textcolor{Black}{\texttt{=}} %
\synt{значение_константы}\}\\
%
\indent\synt{значение_константы}$|$\synt{выражение}|%
\textcolor{Black}{\texttt{(}}\synt{значение_константы}\{\textcolor{Black}{,} \synt{значение_константы}\}\textcolor{Black}{\texttt{)}}\\
%
\indent\synt{имя_константы}$|$\synt{идентификатор}
}}

    \subsection{Описание функций}
Описание алгоритма имеет следующую структуру:

\textcolor{Green}{%
\syntax{%
\synt{описание_функции}$|$(\textcolor{Black}{\textbf{main}}/\textcolor{Black}{\textbf{clean}}) \textcolor{Black}{\textbf{функция}} \synt{имя_функции} %
\synt{сигнатура}\text{[}\synt{реализация}|\textcolor{Black}{;}]
\\
\indent\synt{реализация}$|$\textcolor{Black}{\texttt{\{}} \{\synt{описание}/\synt{операторы}\} \textcolor{Black}{\texttt{\}}}\\
%
\indent\synt{операторы}$|$\synt{оператор}\{\textcolor{Black}{;} \synt{оператор}\}\\
%
\indent\synt{имя_функции}$|$\synt{идентификатор}
}}


Необязательное ключевое слово \textbf{main} означает, что выполнение модуля начинается с этой функции. Функций с атрибутом \textbf{main} в модуле может быть не более одной.
    
Необязательное ключевое слово \textbf{clean} означает, что функция не имеет побочных эффектов.   
   
\section{Выражения}

Синтаксис выражений можно записать так:

\textcolor{Green}{\syntax{\\
\indent\synt{выражение}$\to$\synt{выражение}$_0$[\synt{операция_присваивания} \synt{выражение}]\\
%
\indent\synt{выражение}$_0\to$\synt{выражение}$_1$[(\textcolor{Black}{\texttt{?}}|\textcolor{Black}{\texttt{?.}})\synt{выражение}$_1$ \textcolor{Black}{\texttt{:}} \synt{выражение}$_1$]\\
%
\indent\synt{выражение}$_1$$\to$\synt{выражение}$_2$\{%
(\textcolor{Black}{\texttt{||}}|\textcolor{Black}{\texttt{||.}}|\textcolor{Black}{\texttt{!||}}|\textcolor{Black}{\texttt{!||.}}|\textcolor{Black}{\texttt{\^{ }\^{ }}})%
\synt{выражение}$_2$\}\\
%
\indent\synt{выражение}$_2$$\to$\synt{выражение}$_3$\{%
(\textcolor{Black}{\texttt{\&\&}}|\textcolor{Black}{\texttt{\&\&.}}|\textcolor{Black}{\texttt{!\&\&}}|\textcolor{Black}{\texttt{!\&\&.}})\synt{выражение}$_3$\}\\
%
\indent\synt{выражение}$_3$$\to$\{\textcolor{Black}{\texttt{!}}\}\synt{выражение}$_4$\\
%
\indent\synt{выражение}$_4$$\to$\synt{выражение}$_5$\{%
(\textcolor{Black}{\texttt{<}}|\textcolor{Black}{\texttt{>}}|\textcolor{Black}{\texttt{<=}}|\textcolor{Black}{\texttt{>=}}|\textcolor{Black}{\texttt{==}}|%
\textcolor{Black}{\texttt{!=}})\synt{выражение}$_5$\}\\
%
\indent\synt{выражение}$_5$$\to$\synt{выражение}$_6$\{%
(\textcolor{Black}{\texttt{|}}|\textcolor{Black}{\texttt{\~{ }|}}|\textcolor{Black}{\texttt{\^{ }}})\synt{выражение}$_6$\}\\
%
\indent\synt{выражение}$_6$$\to$\synt{выражение}$_7$\{%
(\textcolor{Black}{\texttt{\&}}|\textcolor{Black}{\texttt{\~{ }\&}}|\textcolor{Black}{\texttt{<{}<}}|\textcolor{Black}{\texttt{>{}>}})\synt{выражение}$_76$\}\\
%
\indent\synt{выражение}$_7$$\to$\{\textcolor{Black}{\texttt{\~{ }}}\}\synt{выражение}$_8$\\
%
\indent\synt{выражение}$_8$$\to$\synt{выражение}$_9$\{%
(\textcolor{Black}{\texttt{+}}|\textcolor{Black}{\texttt{+.}}|\textcolor{Black}{\texttt{-}}|\textcolor{Black}{\texttt{-.}})\synt{выражение}$_9$\}\\
%
\indent\synt{выражение}$_9$$\to$\synt{выражение}$_{10}$\{%
(\textcolor{Black}{\texttt{*}}|\textcolor{Black}{\texttt{*.}}|\textcolor{Black}{\texttt{/}}|\textcolor{Black}{\texttt{/.}}|\textcolor{Black}{\texttt{\%}}|%
\textcolor{Black}{\texttt{\%.}})\synt{выражение}$_{10}$\}\\
%
\indent\synt{выражение}$_{10}$$\to$\synt{выражение}$_{11}$[%
(\textcolor{Black}{\texttt{**}}|\textcolor{Black}{\texttt{**.}})\synt{выражение}$_{10}$]\\
%
\indent\synt{выражение}$_{11}$$\to$\synt{выражение}$_{12}$[\textcolor{Black}{\texttt{\#}}\synt{выражение}$_{12}$]\\
%
\indent\synt{выражение}$_{12}$$\to$\{%
(\textcolor{Black}{\texttt{+{}+}}|\textcolor{Black}{\texttt{-{}-}}|\textcolor{Black}{\texttt{+{}+<}}|\textcolor{Black}{\texttt{-{}-<}})\}\synt{выражение}$_{13}$\\
%
\indent\synt{выражение}$_{13}$$\to$[\textcolor{Black}{\texttt{\#}}]\synt{выражение}$_{14}$\\
%
\indent\synt{выражение}$_{14}$$\to$[%
(\textcolor{Black}{\texttt{+}}|\textcolor{Black}{\texttt{-}})]\synt{выражение}$_{15}$\\
%
\indent\synt{выражение}$_{15}$$\to$[\textcolor{Black}{\texttt{@}}|\textcolor{Black}{\texttt{@@}}|\textcolor{Black}{\texttt{\#\#}}|%
\textcolor{Black}{\texttt{\#\#\#}}]\synt{выражение}$_{16}$\\
%
\indent\synt{выражение}$_{16}$$\to$%
(\textcolor{Black}{\textbf{выделение}}|\textcolor{Black}{\textbf{освобождение}})%\\
\textcolor{Black}{\texttt{(}}\synt{имя}\{\textcolor{Black}{\texttt{,}}\synt{выражение}\}\textcolor{Black}{\texttt{)}}|\synt{литёра}|\synt{строка}|\synt{целое}|\\
\synt{вещественное}|\synt{комплексное}|\textcolor{Black}{\textbf{истина}}|\textcolor{Black}{\textbf{ложь}}|\textcolor{Black}{\textbf{ничто}}|\synt{имя}|%
\textcolor{Black}{\texttt{(}}\synt{выражение}\textcolor{Black}{\texttt{)}}\\
%
\indent\synt{имя_модуля}$\to$\synt{идентификатор}\\
%
\indent\synt{имя}$\to$%
\synt{идентификатор}\{\textcolor{Black}{\texttt{.}}\synt{идентификатор}|\textcolor{Black}{\texttt{@}}|%
\textcolor{Black}{\texttt{[}}\synt{выражение}\{\textcolor{Black}{\texttt{,}}\synt{выражение}\}\textcolor{Black}{\texttt{]}}|\\
\textcolor{Black}{\texttt{(}}[\synt{выражение}\{\textcolor{Black}{\texttt{,}}\synt{выражение}\}]\textcolor{Black}{\texttt{)}}\}
}}
   
\section{Операторы}

    \subsection{Операторы присваивания}

Синтаксис оператора присваивания:
\begin{center}
\textcolor{Green}{\syntax{\synt{имя}%
(\textcolor{Black}{\texttt{=}}|\textcolor{Black}{\texttt{:=}}|\textcolor{Black}{\texttt{||=}}|\textcolor{Black}{\texttt{||.=}}|\textcolor{Black}{\texttt{!||=}}|%
\textcolor{Black}{\texttt{!||.=}}|\textcolor{Black}{\texttt{\&\&=}}|\textcolor{Black}{\texttt{\&\&.=}}|\textcolor{Black}{\texttt{!\&\&=}}|%
\textcolor{Black}{\texttt{!\&\&.=}}|\textcolor{Black}{\texttt{\^{ }\^{ }=}}|\textcolor{Black}{\texttt{|=}}|\textcolor{Black}{\texttt{\&=}}|%
\textcolor{Black}{\texttt{\~{ }|=}}|\textcolor{Black}{\texttt{\~{ }\&=}}|\textcolor{Black}{\texttt{\^{ }=}}|\\
\textcolor{Black}{\texttt{<{}<=}}|\textcolor{Black}{\texttt{>{}>=}}|\textcolor{Black}{\texttt{+=}}|\textcolor{Black}{\texttt{-=}}|\textcolor{Black}{\texttt{*=}}|%
\textcolor{Black}{\texttt{/=}}|\textcolor{Black}{\texttt{\%=}}|\textcolor{Black}{\texttt{**=}}|%
\textcolor{Black}{\texttt{+.=}}|\textcolor{Black}{\texttt{-.=}}|\textcolor{Black}{\texttt{*.=}}|%
\textcolor{Black}{\texttt{/.=}}|\textcolor{Black}{\texttt{\%.=}}|\textcolor{Black}{\texttt{**.=}})\synt{выражение} }}
\end{center}

Все эти операторы можно разделить на три группы: простой оператор присваивания (\texttt{=}), оператор копирования (\texttt{:=}) и все прочие операторы присваивания.
Отличие оператора копирования от оператора присваивания состоит в поведении для динамических массивов: в этом случае оператор присваивания копирует
ссылки на значения (точнее, служебные сведения, в которые входят эти ссылки), а оператор копирования копирует сами значения. 


    \subsection{Условный оператор}
Синтаксис условного оператора:

\noindent\textcolor{Green}{\syntax{%
\noindent\textcolor{Black}{\textbf{if}}\textcolor{Black}{\texttt{[}}\synt{условие}\textcolor{Black}{\texttt{]}}\textcolor{Black}{\textbf{then}}%\\
\textcolor{Black}{\texttt{\{}} \{\synt{описание}/\synt{операторы}\} \textcolor{Black}{\texttt{\}}}\\
\{\textcolor{Black}{\textbf{usl}}\textcolor{Black}{\texttt{[}}\synt{условие}\textcolor{Black}{\texttt{]}}\textcolor{Black}{\textbf{then}}%\\
\textcolor{Black}{\texttt{\{}} \{\synt{описание}/\synt{операторы}\} \textcolor{Black}{\texttt{\}}}\}\\
\text{(}\textcolor{Black}{\textbf{else}}\textcolor{Black}{\texttt{\{}} \{\synt{описание}/\synt{операторы}\} \textcolor{Black}{\texttt{\}}})%
}}

Здесь \textcolor{Green}{\syntax{\synt{условие}}} --- это логическое выражение, а
\textcolor{Green}{\syntax{\textcolor{Black}{\textbf{usl}}\textcolor{Black}{\texttt{(}}\synt{условие}\textcolor{Black}{\texttt{)}}\textcolor{Black}{\textbf{then}}%\\
\textcolor{Black}{\texttt{\{}} \{\synt{описание}|\synt{операторы}\} \textcolor{Black}{\texttt{\}}} }} является сокращённой формой для
\textcolor{Green}{\syntax{\textcolor{Black}{\textbf{else}}\textcolor{Black}{\texttt{\{}} \textcolor{Black}{\textbf{if}}\textcolor{Black}{\texttt{(}}\synt{условие}%
\textcolor{Black}{\texttt{)}}\textcolor{Black}{\textbf{then}}%\\
\textcolor{Black}{\texttt{\{}} \{\synt{описание}|\synt{операторы}\} \textcolor{Black}{\texttt{\}}} \textcolor{Black}{\texttt{\}}}%
}}.


    \subsection{Операторы цикла}
Операторы цикла организуют выполнение повторяющихся действий. Всего в языке есть два типа операторов цикла: while и for. Опишем каждый из этих операторов.


        \subsubsection{Оператор цикла while}
Оператор цикла while выглядит так:
\begin{center}
\textcolor{Black}{\textbf{while}}\textcolor{Black}{\texttt{[}}\synt{условие}%
\textcolor{Black}{\texttt{]}}\textcolor{Black}{\texttt{\{}} \{\synt{описание}/\synt{операторы}\} \textcolor{Black}{\texttt{\} }}
\end{center}
Здесь \textcolor{Green}{\syntax{\synt{условие}}} --- это логическое выражение.
Оператор \textbf{\glqq while\grqq}\ выполняет тело цикла, пока логическое выражение
\textcolor{Green}{\syntax{\synt{условие}}} остаётся истинным. Истинность этого логического выражения проверяется перед каждым выполнением тела цикла (т.е.
операторов \textcolor{Green}{\syntax{\synt{операторы}}}).
    

        \subsubsection{Оператор цикла for}
Оператор цикла \textbf{for}\ выглядит так:
\begin{center}
\textcolor{Black}{\textbf{for}}%
[\synt{a} \textcolor{Black}{\texttt{=}} \textcolor{Black}{\texttt{нач_знач}, \synt{a} \textcolor{Black}{\texttt{=}} }\textcolor{Black}{\texttt{кон_зн}}\textcolor{Black}{\texttt{, шаг}}]%
\textcolor{Black}{\texttt{\{}} \{\synt{описание}/\synt{операторы}\} \textcolor{Black}{\texttt{\} }}
\end{center}

Здесь \textcolor{Green}{\syntax{\synt{a}}} --- идентификатор, являющийся именем переменной цикла; \texttt{нач_знач} --- начальное значение переменной цикла;
\texttt{кон_знач} --- конечное значение переменной цикла; \texttt{шаг} --- шаг цикла. По умолчанию шаг равен единице. Величины \texttt{нач_знач}, \texttt{кон_знач} и
\texttt{шаг} являются выражениями, вычисляемыми до начала цикла. Переменная цикла должна быть символьного, целочисленного или перечислимого типа. Выражения \texttt{нач_знач} и
\texttt{кон_знач} должны иметь тип, совместимый с типом переменной \textcolor{Green}{\syntax{\synt{a}}}, а выражение \texttt{шаг} должно быть целочисленного типа.
Менять в теле цикла значение переменной цикла нельзя.


    \subsection{Оператор выхода из цикла break}

Синтаксис оператора выхода из цикла break:
\begin{center}
\textcolor{Black}[\texttt{Цикл}]%
\textcolor{Black}{\texttt{\{}} break \textcolor{Black}{\texttt{\} }}
\end{center}
Когда оператор break выполняется в цикле, то досрочно прерывается исполнение оператора цикла, и управление передаётся следующему оператору после цикла.
         
\end{document}